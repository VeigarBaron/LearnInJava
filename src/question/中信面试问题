1.java基础 object类有哪些方法 这些方法的作用  常见的hashcode equals ，修改equals方法后需要修改hashcode方法么  需要，为什么需要
    1．clone方法
    保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。
    主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法。
    2．getClass方法
    final方法，获得运行时类型。
    3．toString方法
    该方法用得比较多，一般子类都有覆盖。
    4．finalize方法
    该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。
    5．equals方法
    该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。
    6．hashCode方法
    该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。
    一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。
    如果不重写hashcode(),在HashSet中添加两个equals的对象，会将两个对象都加入进去。
    7．wait方法
    wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。
    调用该方法后当前线程进入睡眠状态，直到以下事件发生。
    （1）其他线程调用了该对象的notify方法。
    （2）其他线程调用了该对象的notifyAll方法。
    （3）其他线程调用了interrupt中断该线程。
    （4）时间间隔到了。
    此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。
    8．notify方法
    该方法唤醒在该对象上等待的某个线程。
    9．notifyAll方法
    该方法唤醒在该对象上等待的所有线程。
4.多线程开发，线程池构件的参数，核心线程数、最大线程数、等待队列，在什么时候会新建线程处理新来的请求
    线程池有这么几个重要的参数：
      corePoolSize=>
       线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，
       继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。
       当线程数小于等于corePoolSize时，默认情况下线程会一直存活在线程池中，即时线程处于空闲状态。如果allowCoreThreadTimeOut被设置为true时，
       无论线程数多少，那么线程处于空闲状态超过一定时间就会被销毁掉。
    maximumPoolSize=> 线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize
    keepAliveTime=>
        线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间；默认情况下，该参数只在线程数大于corePoolSize时才有用；如果allowCoreThreadTimeOut
        被设置为true时，无论线程数多少，线程处于空闲状态超过一定时间就会被销毁掉。
    unit=> keepAliveTime的时间单位,比如分钟,小时等
    workQueue=> 用来保存等待被执行的任务的阻塞队列，且任务必须实现Runnable接口
    threadFactory=> 线程工厂用来创建新的线程放入线程池
    handler
        线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：
        AbortPolicy：直接抛出异常，默认策略；
        CallerRunsPolicy：用调用者所在的线程来执行任务；
        DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；
        DiscardPolicy：直接丢弃任务；
==5.同步锁的使用，synchronize和lock区别，加锁原理
Lock与synchronized的区别如下：
    1.Lock是一个接口,synchronized则是内置的语言实现，在java中是一个关键字
    2.synchronized会自动释放锁，而Lock必须手动释放锁
    3.Lock可以让等待锁的线程响应中断，而synchronized不会，线程会一直等待下去
    4.通过Lock可以知道线程有没有拿到锁，而synchronized不能
    5.Lock能提高多个线程读操作的效率
    6.synchronized能锁住类、方法和代码块，而Lock是块范围内的
    7.Lock 实现了提供比使用 synchronized 方法和语句可获得的更广泛的锁定操作
==6.volatile关键字能够保证什么效果，顺序性和可见性，怎么保证的
7.使用过哪些容器类，list set ,说说底层原理
==8.jvm相关问题，结构，垃圾回收策略，垃圾回收器，什么时候younggc  什么时候full gc，举例说明一个对象创建时是分配在哪个区域
9.根据简历上的项目和使用工具，问一些redis概述，支持哪些数据类型，es为什么快，使用了什么索引--倒排索引
11.mysql索引，聚集索引用的什么数据结构  B+树，为什么用B+树，不是二叉树 B树？减少磁盘读写，普通索引
InnoDB一棵B+树可以存放多少行数据？这个问题的简单回答是：约2千万。
    这里我们先假设B+树高为2，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：根节点指针数*单个叶子节点记录行数。
    上文我们已经说明单个叶子节点（页）中的记录数=16K/1K=16。（这里假设一行记录的数据大小为1k）。
    那么现在我们需要计算出非叶子节点能存放多少指针，其实这也很好算，我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，
    这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即16384/14=1170。那么可以算出一棵高度为2的B+树，能存放1170*16=18720条这样的数据记录。
    根据同样的原理我们可以算出一个高度为3的B+树可以存放：1170*1170*16=21902400条这样的记录。所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。
    在查找数据时 一次页的查找代表一次IO， 所以通过主键索引查询通常 只需要1-3次IO操作 即可查找到数据。
    在计算机中磁盘存储数据最小单元是扇区，一个扇区的大小是512字节，而文件系统（例如XFS/EXT4）他的最小单元是块，
    一个块的大小是4k，而对于我们的InnoDB存储引擎也有自己的最小储存单元——页（Page），一个页的大小是16K。
==12.jdk8的一些新特性用了哪些，lamda stream  原理，为什么用。。简单说说 他也不太懂
13.其他随便闲聊了
数据库最左匹配原则，设计模式知道那些，数据结构，二分查找法
tcp/ip      http通信      spring的配置文件怎么改成的注解
