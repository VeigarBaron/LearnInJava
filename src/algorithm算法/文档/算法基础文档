「时效」是指时间效率，也就是算法的执行时间，对于同一个问题的多种不同解决算法，执行时间越短的算法效率越高，越长的效率越低。
「存储」是指算法在执行的时候需要的存储空间，主要是指算法程序运行的时候所占用的内存空间。

====数组、字符串（Array & String）

====链表
    应用场景：如果要解决的问题里面需要很多快速查询，链表可能并不适合；如果遇到的问题中，数据的元素个数不确定，而且需要经常进行
数据的添加和删除，那么链表会比较合适。而如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合。
1. 利用快慢指针（有时候需要用到三个指针）
    典型题目例如：链表的翻转，寻找倒数第 k 个元素，寻找链表中间位置的元素，判断链表是否有环等等。
2. 构建一个虚假的链表头
    一般用在要返回新的链表的题目中，比如，给定两个排好序的链表，要求将它们整合在一起并排好序。又比如，将一个链表中的奇数和偶数
  按照原定的顺序分开后重新组合成一个新的链表，链表的头一半是奇数，后一半是偶数。

====队列（Queue）
    特点：和栈不同，队列的最大特点是先进先出（FIFO），就好像按顺序排队一样。对于队列的数据来说，我们只允许在队尾查看和添加数
  据，在队头查看和删除数据。
    实现：可以借助双链表来实现队列。双链表的头指针允许在队头查看和删除数据，而双链表的尾指针允许我们在队尾查看和添加数据。
    应用场景：直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法
  面试题当中，广度优先搜索（Breadth-First Search）是运用队列最多的地方。

====双端队列（Deque）
    应用场景：双端队列最常用的地方就是实现一个长度动态变化的窗口或者连续区间，而动态窗口这种数据结构在很多题目里都有运用。

====树（Tree）
    常考的树的形状有：普通二叉树、平衡二叉树、完全二叉树、二叉搜索树、四叉树（Quadtree）、多叉树（N-ary Tree）。
1. 前序遍历（Preorder Traversal）
    方法：先访问根节点，然后访问左子树，最后访问右子树。
    应用场景：运用最多的场合包括在树里进行搜索以及创建一棵新的树。
2. 中序遍历（Inorder Traversal）
    方法：先访问左子树，然后访问根节点，最后访问右子树
    应用场景：最常见的是二叉搜索树，由于二叉搜索树的性质就是左孩子小于根节点，根节点小于右孩子，对二叉搜索树进行中序遍历的时候，
  被访问到的节点大小是按顺序进行的。
3. 后序遍历（Postorder Traversal）
    方法：先访问左子树，然后访问右子树，最后访问根节点。
    应用场景：在对某个节点进行分析的时候，需要来自左子树和右子树的信息。

========
1. 优先队列
经常出现在考题里的，它的实现过程比较繁琐，但是很多编程语言里都有它的实现，所以在解决面试中的问题时，实行“拿来主义”即可。
鼓励你自己练习实现一个优先队列，在实现它的过程中更好地去了解它的结构和特点。
2. 图
被广泛运用的数据结构，很多涉及大数据的问题都得运用到图论的知识。
比如在社交网络里，每个人可以用图的顶点表示，人与人直接的关系可以用图的边表示；再比如，在地图上，要求解从起始点到目的地，如何行驶会更快捷，需要运用图论里的最短路径算法。
3. 前缀树
出现在许多面试的难题当中。
因为很多时候你得自己实现一棵前缀树，所以你要能熟练地书写它的实现以及运用它。
4. 线段树和树状数组
应用场合比较明确。
例如，问题变为在一幅图片当中修改像素的颜色，然后求解任意矩形区间的灰度平均值，那么可以考虑采用二维的线段树了。
================
1. 基本的排序算法
冒泡排序（Bubble Sort）
插入排序（Insertion Sort）

2. 常考的排序算法
归并排序（Merge Sort）
快速排序（Quick Sort）
拓扑排序（Topological Sort）

3. 其他排序算法
堆排序（Heap Sort）
桶排序（Bucket Sort)
==================


内排序有可以分为以下几类：
　　(1)、插入排序(InsertionSort)：直接插入排序、二分法插入排序、希尔排序。
　　(2)、选择排序(SelectionSort)：直接选择排序、堆排序。
　　(3)、交换排序(SwapSort)：冒泡排序、快速排序。
　　(4)、归并排序(MergeSort)
　　(5)、基数排序(radixSort)

排序方法	    时间复杂度（平均）	    时间复杂度（最坏)   时间复杂度（最好)	 空间复杂度   稳定性   复杂性
直接插入排序	    O(n2)               O(n2)	        O(n)	        O(1)    稳定	    较复杂
冒泡排序	        O(n2)	            O(n2)	        O(n)	        O(1)	稳定	    简单
快速排序	        O(nlog2n)	        O(n2)	        O(nlog2n)	    O(1)	不稳定	较复杂
归并排序	        O(nlog2n)	        O(nlog2n)	    O(nlog2n)	    O(n)	稳定	    较复杂
基数排序	        O(d(n+r))	        O(d(n+r))	    O(d(n+r))	    O(n+r)	稳定	    较复杂

一、平均时间复杂度O(n2)：
    冒泡、选择、插入排序：当原始数组接近有序时，插入排序性能最优；当原始数组大部分元素无序时，选择排序性能最优
二、希尔排序：O（n^1.3）
    快速、归并、堆排序：O（nlogn）
三、计数O（n+m）、桶O（n）、基数排序O（k（n+m））

分治算法、动态规划算法、贪心算法、回溯法、分治界限法
如果对时间复杂度的要求有 log，通常都需要用到二分查找