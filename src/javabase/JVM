运行时数据区：
    线程私有的：
        虚拟机栈：Java方法（局部变量表、操作数栈、动态链接、方法出口）
        本地⽅法栈：native方法
        程序计数器：虚拟机字节码指令的地址或undefined
    线程共享的：
        堆：几乎所有的对象实例以及数组   (          栈上分配、标量替换、逃逸分析
                            1.方法区中，静态变量或常量的reference指向堆中实例；
                            2.虚拟机栈中，局部变量表的reference指向堆中实例；
                            3.本地方法栈中，JNI的reference指向堆中实例；
                            4.堆中，实例指向实例；
                         )
        ⽅法区(元空间)：类信息、常量、静态变量、字符串字面量和数字常量、即时编译器编译后的代码
        直接内存(⾮运⾏时数据区的⼀部分)
        运行时常量池：
        JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代
        JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代 。
        JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)

程序计数器：是⼀块⼩的内存空间，可以看作是当前线程所执⾏的字节码的⾏号指示器。
    1. 字节码解释器通过改变程序计数器来依次读取指令，从⽽实现代码的流程控制，如：顺序执⾏、选择、循环、异常处理。
    2. 在多线程的情况下，程序计数器⽤于记录当前线程执⾏的位置，从⽽当线程被切换回来的时候能够知道该线程上次运⾏到哪⼉了。

Java虚拟机栈：也是线程私有的，它的⽣命周期和线程相同，描述的是Java⽅法执⾏的内存模型，每次⽅法调⽤的数据都是通过栈传递的。
    栈内存(Stack),其中栈就是现在说的虚拟机栈。或者说是虚拟机栈中局部变量表部分。
    Java虚拟机栈是由⼀个个栈帧组成，⽽每个栈帧（Java方法）中都拥有：局部变量表、操作数栈、动态链接、⽅法出⼝信息。

本地方法栈：虚拟机栈为虚拟机执⾏ Java ⽅法 （也就是字节码）服务，⽽本地⽅法栈则为虚拟机使⽤到的 Native ⽅法服务。
    在 HotSpot 虚拟机中和 Java 虚拟机栈合⼆为⼀。
    本地⽅法被执⾏的时候，在本地⽅法栈也会创建⼀个栈帧，⽤于存放该本地⽅法的局部变量表、操作数栈、动态链接、出⼝信息。

堆：Java 堆是所有线程共享的⼀块内存区域，在虚拟机启动时创建。此内存区域的唯⼀⽬的就是存放对象实例，
    ⼏乎所有的对象实例以及数组都在这⾥分配内存。
    Java 堆是垃圾收集器管理的主要区域，因此也被称作GC堆

方法区：⽅法区也被称为永久代。永久代是HotSpot的概念，⽅法区是Java虚拟机规范中的定义，是⼀种规范，⽽永久代是⼀种实现，其他的虚拟机实现并没有永久代这⼀说法。
    整个永久代有⼀个 JVM 本身设置固定⼤⼩上限，⽆法进⾏调整，⽽元空间使⽤的是直接内存，受本机可⽤内存的限制，并且永远不会得到OutOfMemoryError。
    运⾏时常量池： 运⾏时常量池是⽅法区的⼀部分。
        JDK1.7及之后版本的 JVM 已经将运⾏时常量池从⽅法区中移了出来，在 Java 堆（Heap）中开辟了⼀块区域存放运⾏时常量池。

直接内存：直接内存并不是虚拟机运⾏时数据区的⼀部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使⽤。
    ⽽且也可能导致 OutOfMemoryError 异常出现。


对象的创建过程？
    Step1:类加载检查：虚拟机遇到⼀条 new 指令时，⾸先将去检查这个指令的参数是否能在常量池中定位到
                这个类的符号引⽤，并且检查这个符号引⽤代表的类是否已被加载过、解析和初始化过。如果没有，那
                必须先执⾏相应的类加载过程。（1.7之后在Java堆中）
    Step2:分配内存：为对象分配空间的任务等同于把⼀块确定⼤⼩的内存从 Java 堆中划分出来。
        内存分配的两种⽅式：
            Java堆是否规整由所采⽤的垃圾收集器是否带有压缩整理功能决定。
            指针碰撞：
                1.适用于堆内存规整（没有内存碎片的情况下）
                2.将用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界值指针，只需要向着没有用过的内存方向将该指针移动
                    对象内存大小的位置即可
                3.GC收集器：Serial,ParNew
            空闲列表：
                1.适用于堆内存不规整的情况下
                2.虚拟机会维护一个列表，该列表中将会记录那些内存块是可用的，在分配的时候，找一块足够大的内存块来划分给实例，最后更新列表记录。
                3.GC收集器：CMS
        虚拟机采⽤两种⽅式来保证线程安全：
            CAS+失败重试： CAS 是乐观锁的⼀种实现⽅式。所谓乐观锁就是，每次不加锁⽽是假设没有冲突⽽去完成某项操作，如果因为冲突失败就重试，
                直到成功为⽌。虚拟机采⽤ CAS 配上失败重试的⽅式保证更新操作的原⼦性。
            TLAB： 为每⼀个线程预先在Eden区分配⼀块⼉内存，JVM在给线程中的对象分配内存时，⾸先在TLAB分配，当对象⼤于TLAB中的剩余内存
                或TLAB的内存已⽤尽时，再采⽤上述的CAS进⾏内存分配。
    Step3:初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。
    Step4:设置对象头：初始化零值完成之后，虚拟机要对对象进⾏必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、
        对象的 GC 分代年龄等信息。 这些信息存放在对象头中。
    Step5:执行init方法：<init> ⽅法还没有执⾏，需要执行<init> ⽅法，把对象按照程序员的意愿进⾏初始化。

对象的访问定位有哪两种⽅式?
    建⽴对象就是为了使⽤对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问⽅式有虚拟机实现⽽定，
        ⽬前主流的访问⽅式有①使⽤句柄②直接指针两种。

Minor Gc和Full GC 有什么不同呢？
    新⽣代GC（Minor GC）:指发⽣新⽣代的的垃圾收集动作，Minor GC⾮常频繁，回收速度⼀般也⽐较快。
    ⽼年代GC（Major GC/Full GC）:指发⽣在⽼年代的GC，出现了Major GC经常会伴随⾄少⼀次的Minor GC（并⾮绝对），
        Major GC的速度⼀般会⽐Minor GC的慢10倍以上。

如何判断对象是否死亡?
    引用计数法，可达性分析法。

类需要同时满⾜下⾯3个条件才能算是 “⽆⽤的类” ：
    该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
    加载该类的 ClassLoader 已经被回收。
    该类对应的 java.lang.Class 对象没有在任何地⽅被引⽤，⽆法在任何地⽅通过反射访问该类的⽅法。

垃圾收集有哪些算法，各⾃的特点？
    标记-清除算法：内存浪费、效率低     老年
    复制算法：浪费空间               年轻
    标记-整理算法                   老年
    分代收集算法：
    年轻代（minor GC）
            Eden    from S    to S
            8         1         1
    进入老年代（full GC）方法：1.内存担保机制、2.年龄达到老年代年龄
常⻅的垃圾回收器有那些?
    Serial收集器：              单线程     STW     新生代收集器
    ParNew收集器：              多线程     STW     新生代收集器
    Parallel Scavenge收集器：     吞吐量           新生代收集器
    Serial Old收集器：          单线程     STW     老年代收集器
    Parallel Old收集器：           吞吐量          老年代收集器
    CMS1.5收集器：rset
        并发-标记-清除  初始标记STW-并发标记-重新标记STW-并发清除
        1.cpu资源敏感
        2.浮动垃圾：并发清理中的产生的垃圾（过多时，产生并发模式失败机制 - 进行serial old模式）
        3.算法产生垃圾碎片
    G1(G first)收集器: JDK9之后的默认，原则就是 简单可行的性能调优：rset
        区域打散后，灵活应用： Eden、s、old、humongous
        Mix垃圾回收：
    ==========jvm 参数===============
    参数：                 描述
    -Xms                设置JVM启动时初始化堆大小
    -Xmx                设置堆得最大值
    -Xmn                设置年轻代大小
    -XX:PermGen         设置老年代的初始大小
    -XX:MaxPermGen      设置老年代的最大值
    -XX:SurivorRatio    设置Eden区和Surivor区的比例，默认为8
    -XX:NewRatio        设置老年代和年轻代的比例，默认为2
    ==========GC 参数================
    -XX:+UseSerialGC            client模式
    -XX:+UseParallelGC          采用Parallel Scanvenge + Serial Old 组合
    -XX:+UseParallelOldGC       采用Parallel Scanvenge + Parallel Old 组合
    -XX:+ParNewGC               ParNew + Serial Old 组合
    -XX:+UseConMarkSweepGC      ParNew + CMS + Serial Old 组合
    -XX:+UseG1GC                采用G1收集器
